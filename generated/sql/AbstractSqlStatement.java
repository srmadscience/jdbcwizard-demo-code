package com.orindasoft.demo.generated.sql;


import java.sql.*; 
import com.orindasoft.pub.LogInterface; 
import com.orindasoft.pub.OracleResourceUser; 
import com.orindasoft.pub.StatementParameters2;
import com.orindasoft.pub.CSException; 

/** 
* Abstract SQL statement class for all classes generated by JDBCWizard
* 
* <p>Generated by JDBCWizard build 2814 at 2011/11/22 00:33:44.855 GMT
* <p>JDBCWizard is made by <a href="http://www.orindasoft.com/?pdsrc=GD2814" target="_blank">Orinda Software Ltd, Dublin, Ireland</a>
* <p>Target Database: Oracle 10.2.0
* <p> -------------------------------------------------------------------------
* <p> WARNING: This code will stop working around the time JDBCWizard expires.
* <p> This restriction only exists in the demo version of JDBCWizard.
* <p> -------------------------------------------------------------------------
* <p> JDBCWizard Tips 16 of 19:
* <p> JDBCWizard's com.orindasoft.pub library contains functionality 
* <p> common to generated code, such as parameter binding and logging. 
* <p> If you buy the full version of JDBCWizard you get the source code
* <p> to com.orindasoft.pub as well as the ability to generate all the access
* <p> code you want. 
* <p> -------------------------------------------------------------------------
* 
* <p>Copyright Orinda Software 2003-2009

* <p>Class ChangeFlightDates.sql - Run contents of SQL file ChangeFlightDates
* <p>Class CustcomerAdd.sql - Run contents of SQL file CustcomerAdd
* <p>Class CustomerDelete.sql - Run contents of SQL file CustomerDelete
* <p>Class CustomerUpdate.sql - Run contents of SQL file CustomerUpdate
* @author devteam60@orindabuild.com
* @version 1.1
*/ 
public abstract class AbstractSqlStatement implements OracleResourceUser
{ 
  /** 
  * Constant used for object that is in this users account 
  */ 
  public static final int THIS_USERS_OBJECT = 0; 
  
  /** 
  * Constant used for object that is in an other users account 
  */ 
  public static final int OTHER_USERS_OBJECT = 1; 
  
  /** 
  * Constant used for object that is a refered to by a PRIVATE SYNONYM 
  */ 
  public static final int THIS_USERS_SYNONYM = 2; 
  
  /** 
  * Constant used for object that is a refered to by a PUBLIC SYNONYM 
  */ 
  public static final int PUBLIC_SYNONYM = 3; 
  
  /** 
  * Database Connection 
  */ 
  public Connection theConnection = null; 
  
  /** 
  * An instance of a class which implements com.orindasoft.pub.LogInterface 
  */ 
  public com.orindasoft.pub.LogInterface theLog = null; 
  
  /** 
  * Prepared statment for SQL Statement 
  */ 
  public PreparedStatement theStatement = null; 
  
  /** 
  * Parameters for prepared statement 
  */ 
  public StatementParameters2 theParameters = null; 
  
  /** 
  * Build Number - Added to spot conflicts between version of generated code 
  * and version of com.orindasoft.pub Library. 
  * @since 6.0.2706 
  */ 
  private static final int theBuildNumber =  2814;
  
  /** 
  * Create an instance of AbstractSqlStatement using a database connection and an instance of LogInterface 
  *  @param Connection theConnection A database connection 
  *  @param LogInterface theLog An instance of a class that implements com.orindasoft.pub.LogInterface 
  */ 
  public AbstractSqlStatement(Connection theConnection, LogInterface theLog) 
    { 
    this.theConnection = theConnection; 
    this.theLog = theLog; 
    theParameters = new StatementParameters2(getProcCallStatement(),theLog); 
    } 
   
  /** 
  * Create an instance of AbstractSqlStatement using an instance of LogInterface  
  *  @param LogInterface theLog An instance of a class that implements com.orindasoft.pub.LogInterface  
  */                                   
  public AbstractSqlStatement(LogInterface theLog)      
    {                                                 
    this.theLog = theLog;                             
    theParameters = new StatementParameters2(getProcCallStatement(),theLog); 
    }                                                  
   
  /**  
  * Set or reset the database connection 
  *  @param Connection theConnection A database connection  
  */       
  public void setConnection(Connection theConnection)  
    {                                               
    theLog.debug("AbstractSqlStatement - Setting DB Connection"); //DEBUG
    this.theConnection = theConnection;          
    }                                           
   
  /** 
  * Return a string containing the magic incantation needed to execute this. 
  */ 
  public abstract String getProcCallStatement(); 
  
  /** 
  * Prepare statement if needed 
  */ 
  protected PreparedStatement preparePreparedStatement() throws CSException     
    {                                                                   
    PreparedStatement newPreparedStatement;                                      
                                                                     
    theLog.debug("AbstractSqlStatement - Preparing Statement"); //DEBUG
    // Parse statement...                          
    try                                                              
      {                                                                
      theLog.debug("AbstractSqlStatement - Starting to parse statement");
      newPreparedStatement = theConnection.prepareStatement(getProcCallStatement());    
      theLog.debug("AbstractSqlStatement - Finished parsing statement");
      }                                                                  
    catch (java.sql.SQLException e)                                    
      {    
      theLog.error("AbstractSqlStatement: Prepare Statement failed with " + e.toString());
      throw (new CSException("Unable to parse statement: " + e.toString()));   
      }       
              
                      
    return(newPreparedStatement);  
                        
    }                      
                         
  /** 
  * Create Parameters object if needed. 
  */ 
  protected void createParams(String sqlString)
    {
    theParameters = new StatementParameters2(sqlString,theLog);
    }                                                                   
   
  /** 
  * Bind Parameters object if needed. 
  */ 
  protected abstract void bindParams() throws CSException; 
   
  /** 
  * Make sure connected and statement prepared 
  * This method allows application code to create a live Statement  
  * before JDBCWizard would normally do so. 
  * @throws CSException An error of some kind. See <a href=http://www.orindasoft.com/?pdsrc=GD2814csexeceptions>CSExceptions</a>
  * @since 5.0.2271 connectAndPrepare added
  */ 
  public void connectAndPrepare() throws CSException
    {                                                                   
    if (theConnection == null) 
      {                               
      throw (new CSException("Not Connected - Prepared Statement can not be executed"));  
      }                                    
                                          
    if (theStatement == null)            
      {                                      
      // Parse statement...                   
      theStatement = preparePreparedStatement(); 
       
      // Make sure generated code version matches version of this code...
      com.orindasoft.pub.StatementParameters2.checkBuild(theBuildNumber);
      }     
    }     
         
  /** 
  * Issue statement 
  * @throws CSException An error of some kind. See <a href=http://www.orindasoft.com/?pdsrc=GD2814csexeceptions>CSExceptions</a>
  * @since 4.0.2054 Better Error handling
  * @since 5.0.2271 connectAndPrepare added
  */ 
  public void executeCall() throws CSException
    {                                                                   
    theLog.debug("AbstractSqlStatement - Execute Statement"); //DEBUG
                                                                       
    connectAndPrepare();                                          
                                                                      
    try     
      {       
      // See if our statement is usable. If somebody else who has the connection has called 
      // its commit method out prepared statement will no longer be usable...     
      bindParams();       
      issueCall();        
      }                     
    catch (CSException e)  
      {                 
      theLog.warning("First attempt at execution failed: " + e.toString()); 
      // Re-parse and try again                   
      theStatement = preparePreparedStatement();   
      bindParams();                 
      issueCall();                  
      }                            
    catch (Error e)  
      {                 
      // Log error and throw it - we don't know what it is but at least   
      // the log will show where it was created. This kind of error can occur if  
      // the wrong runtime libraries are in use. 
      theStatement = null;   
      theLog.syserror("Error thrown while trying to execute statement:" + e.getClass().getName() + ":" + e.getMessage());
      throw(e);
      }                            
                                 
    }                       
                               
  
  /** 
  * Execute the statement, keeping track of stats if requested
  * @since 4.0.1798 Now traps java.lang.OutOfMemoryError
  * @since 4.0.2054 Better error handling
  */ 
  private void issueCall() throws CSException  
    {                                         
    theLog.debug("AbstractSqlStatement - Start Execute DB Call"); //DEBUG
    try                                      
      {                                        
      theStatement.executeUpdate();          
      }                                        
    catch (SQLException e)                   
      {                                         
      throw (new CSException(e.toString()));    
      }                                          
    theLog.debug("AbstractSqlStatement - End Execute DB Call"); //DEBUG
    }                                                                   
   
   
  /** 
  * Release all db resources that we know to be in use. Further attempts to use this 
  *  will fail until we are given another connection to play with. 
  * We explicitly rollback at the end of this method. 
  *  @return boolean <code>true</code> if we didn't encounter any problems, otherwise <code>false</code> 
  */ 
   
  public boolean releaseResources() 
    { 
    boolean returnCode = true; 
    
    theLog.debug("AbstractSqlStatement - Attempting to release connection");
    
    try 
      { 
      
      if (theStatement != null)
        { 
        theStatement.close(); 
        } 
      } 
    catch (SQLException e) 
      { 
      theLog.warning(e.toString()); 
      returnCode = false; 
      } 
    
    theConnection = null; 
    theStatement = null; 
    theLog.debug("AbstractSqlStatement- Finished releasing connection");
    
    return(returnCode); 
    } 
  
  /** 
  * Check to see if we are using Oracle Resources
  *  will fail until we are given another connection to play with. 
  * We explicitly rollback at the end of this method. 
  * @return <code>true</code> if we are using resources
  * @return <code>false</code> if we are not using resources
  */ 
  public boolean hasResources() 
    { 
    if (theConnection == null) 
      { 
      return (false); 
      } 
    
    return(true); 
    } 
  } // Generated by JDBCWizard 6.0.2814  

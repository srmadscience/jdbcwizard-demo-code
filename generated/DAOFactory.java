package com.orindasoft.demo.generated;


import java.sql.Connection; 
import com.orindasoft.pub.LogInterface; 
import com.orindasoft.pub.OracleResourceUser; 
import com.orindasoft.pub.CSException; 
import com.orindasoft.pub.CSDBException; 

// From oracle 9.0.1 "oracle.jdbc.driver" is deprecated and 
// its contents move to "oracle.jdbc". "oracle.jdbc.driver" 
// still exists in 9.2.0.
import oracle.jdbc.OracleConnection;
// import oracle.jdbc.driver.OracleConnection;

/** 
* DAO Factory class used by classes generated by JDBCWizard
* 
* <p>Generated by JDBCWizard build 2814 at 2011/11/22 00:33:45.842 GMT
* <p>JDBCWizard is made by <a href="http://www.orindasoft.com/?pdsrc=GD2814" target="_blank">Orinda Software Ltd, Dublin, Ireland</a>
* <p>Target Database: Oracle 10.2.0
* <p> -------------------------------------------------------------------------
* <p> WARNING: This code will stop working around the time JDBCWizard expires.
* <p> This restriction only exists in the demo version of JDBCWizard.
* <p> -------------------------------------------------------------------------
* <p> JDBCWizard Tips 9 of 19:
* <p> JDBCWizard generated code is compatible with Javadoc
* <p> -------------------------------------------------------------------------
* 
* <p>Copyright Orinda Software 2003-2009
* @author devteam60@orindabuild.com
* @version 1.1
*/ 
public class DAOFactory implements OracleResourceUser
{ 
  /** 
  * Value used for array fetches. 
  */ 
  private int arrayFetchSize = 50; 
  
  /** 
  * Value used for batch updates 
  */ 
  private int batchUpdateSize = 1; 
  
  /** 
  * Database Connection 
  */ 
  public Connection theConnection = null; 
  
  /** 
  * An instance of a class which implements com.orindasoft.pub.LogInterface 
  */ 
  public com.orindasoft.pub.LogInterface theLog = null; 
  
  /**
  * Flag that controls whether we commit when releasing connections
  * @see <a href=http://www.orindasoft.com/public/Running%20GUItwo.php4#fouor&pdsrc=GD2814 TARGET=_blank class=news>Altering the behaviour of generated code</a>
  * @since JDBCWizard 4.0.2098
  */
  protected boolean commitOnRelease = true;
  
  /**
  * Flag that controls whether we close the connection when releaseConnection is called
  * @see <a href=http://www.orindasoft.com/public/Running%20GUItwo.php4#fouor&pdsrc=GD2814 TARGET=_blank class=news>Altering the behaviour of generated code</a>
  * @since JDBCWizard 4.0.2107
  * @since JDBCWizard 4.0.2145 Default value is now controlled by UI
  */
  protected boolean closeOnRelease = true;
  
  /**
  * String that if non-null should contain a valid Oracle time zone name.
  * This is used for working with oracle.sql.TIMESTAMPLTZ, which needs  
  * an OracleConnection that has been made time zone aware in order to work.
  * A list of valid time zones is stored in V$TIMEZONE_NAMES and the timezone
  * is set by calling the method setSessionTimeZone(). If the timezone is not
  * set and an attempt is made to use TIMESTAMPLTZ the 
  * java.sql.SQLException "connection session time zone was not set" will be thrown
  * @see oracle.sql.OracleConnection.setSessionTimeZone()
  * @see confirmConnection()
  * @see setOracleTimeZoneName
  * @since JDBCWizard 4.0.2145
  * @since Oracle V9.0.1
  */
  protected String oracleTimeZoneName = null;
  
  /**
  * Buffer Size for downloading files from the DB.
  * @since JDBCWizard 4.0.2043
  * @since JDBCWizard 4.0.2145 Default value is now controlled by UI
  */
  protected int bufferSize = 4096;
  
  /**
  * Temporary directory for downloaded files.
  * @since 4.0.2043
  */
  protected java.io.File tempFileDir = new java.io.File (System.getProperty("user.dir"));
  
  /**
  * boolean flag that controls whether LOBs are turned into byte[]
  * @since 5.0.2314
  */
  protected boolean useByteArraysForLongsAndLOBS = true;
  
  /**
  * Variable to store boolean flag that indicates whether created files should be deleted when the JVM exits.
  */
  protected boolean keepFiles = true;
  
  /**
  * boolean flag that specifies whether lobs such as CLOBS, BLOBS and BFILES
  * will be kept as Oracle objects or downloaded into Files.
  * @since 4.0.2100
  */
  protected boolean keepLobs = false;
  
  /**
  * Prefix for downloaded files containing BLOB, CLOB and BFILE data
  * @since 4.0.2043
  * @since 4.0.2139 The default value for this is now set in the UI
  */
  protected String tempFilePrefix = "OSOFT";
  
  /**
  * Suffix for downloaded files containing BLOB, CLOB and BFILE data
  * @since 4.0.2043
  * @since 4.0.2139 The default value for this is now set in the UI
  */
  protected String tempFileSuffix = ".tmp";
  
  /**
  * long object loader for BLOB, CLOB and BFILE data.
  * This variable is only instantiated if needed.
  * @since 4.0.2108
  */
  protected com.orindasoft.pub.LongObjectLoader lobLoader = null;
  
  /** 
  * Default value for implict SQL statement cache size
  * To turn off the implicit SQL statement cache set this to 0.
  * The initial value is based on the number of SQL statements this service uses.
  * To accept default cache sizes provided by a DataSource set this to -1 
  * @since 5.0.2496 
  */
  protected int implicitSqlCacheSize = 54;
  
  /** 
  * Callable Statment for batch commit
  * @since 5.0.2496 
  */ 
  protected java.sql.CallableStatement batchCommitStatement = null; 
  
  /** 
  * Instance of Class CursorExampleDirectFlightAvailable - Access PL/SQL CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE
  */ 
  protected com.orindasoft.demo.generated.plsql.CursorExampleDirectFlightAvailable theCursorExampleDirectFlightAvailable = null;
  
  /** 
  * Instance of Class CursorExampleFindDirectFlights - Access PL/SQL CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS
  */ 
  protected com.orindasoft.demo.generated.plsql.CursorExampleFindDirectFlights theCursorExampleFindDirectFlights = null;
  
  /** 
  * Instance of Class CursorExampleGetlists - Access PL/SQL CURSOR_EXAMPLE.GETLISTS
  */ 
  protected com.orindasoft.demo.generated.plsql.CursorExampleGetlists theCursorExampleGetlists = null;
  
  /** 
  * Instance of Class ObjectArrayExampleAddBookingsObjectArray - Access PL/SQL OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY
  */ 
  protected com.orindasoft.demo.generated.plsql.ObjectArrayExampleAddBookingsObjectArray theObjectArrayExampleAddBookingsObjectArray = null;
  
  /** 
  * Instance of Class ObjectArrayExampleGetObjectArrayOfFlights - Access PL/SQL OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS
  */ 
  protected com.orindasoft.demo.generated.plsql.ObjectArrayExampleGetObjectArrayOfFlights theObjectArrayExampleGetObjectArrayOfFlights = null;
  
  /** 
  * Instance of Class PackageArrayExampleAddBookingsPlsqlArray - Access PL/SQL PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY
  */ 
  protected com.orindasoft.demo.generated.plsql.PackageArrayExampleAddBookingsPlsqlArray thePackageArrayExampleAddBookingsPlsqlArray = null;
  
  /** 
  * Instance of Class PackageArrayExampleGetPlsqlArrayOfFlights - Access PL/SQL PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS
  */ 
  protected com.orindasoft.demo.generated.plsql.PackageArrayExampleGetPlsqlArrayOfFlights thePackageArrayExampleGetPlsqlArrayOfFlights = null;
  
  /** 
  * Instance of Class PackageIdxarrayExampleAddBookingsPlsqlArray - Access PL/SQL PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY
  */ 
  protected com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleAddBookingsPlsqlArray thePackageIdxarrayExampleAddBookingsPlsqlArray = null;
  
  /** 
  * Instance of Class PackageIdxarrayExampleGetPlsqlArrayOfFlights - Access PL/SQL PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS
  */ 
  protected com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleGetPlsqlArrayOfFlights thePackageIdxarrayExampleGetPlsqlArrayOfFlights = null;
  
  /** 
  * Instance of Class AircraftMgr - Access Table AIRCRAFT
  */ 
  protected com.orindasoft.demo.generated.table.manager.AircraftMgr TheAircraftMgr = null;
  
  /** 
  * Instance of Class AirlinesMgr - Access Table AIRLINES
  */ 
  protected com.orindasoft.demo.generated.table.manager.AirlinesMgr TheAirlinesMgr = null;
  
  /** 
  * Instance of Class AirportsMgr - Access Table AIRPORTS
  */ 
  protected com.orindasoft.demo.generated.table.manager.AirportsMgr TheAirportsMgr = null;
  
  /** 
  * Instance of Class BookingsMgr - Access Table BOOKINGS
  */ 
  protected com.orindasoft.demo.generated.table.manager.BookingsMgr TheBookingsMgr = null;
  
  /** 
  * Instance of Class CustomersMgr - Access Table CUSTOMERS
  */ 
  protected com.orindasoft.demo.generated.table.manager.CustomersMgr TheCustomersMgr = null;
  
  /** 
  * Instance of Class FlightsMgr - Access Table FLIGHTS
  */ 
  protected com.orindasoft.demo.generated.table.manager.FlightsMgr TheFlightsMgr = null;
  
  /** 
  * Instance of Class SequentialNumberGenerator - Access Sequence SEQUENTIAL_NUMBER_GENERATOR
  */ 
  protected com.orindasoft.demo.generated.sequence.SequentialNumberGenerator theSequentialNumberGenerator = null;
  
  /** 
  * Instance of Class ChangeFlightDates
  */ 
  protected com.orindasoft.demo.generated.sql.ChangeFlightDates theChangeFlightDates = null;
  
  /** 
  * Instance of Class CustcomerAdd
  */ 
  protected com.orindasoft.demo.generated.sql.CustcomerAdd theCustcomerAdd = null;
  
  /** 
  * Instance of Class CustomerDelete
  */ 
  protected com.orindasoft.demo.generated.sql.CustomerDelete theCustomerDelete = null;
  
  /** 
  * Instance of Class CustomerUpdate
  */ 
  protected com.orindasoft.demo.generated.sql.CustomerUpdate theCustomerUpdate = null;
  
  /** 
  * Instance of Class GetFlights
  */ 
  protected com.orindasoft.demo.generated.sql.GetFlights theGetFlights = null;
  
   
  /** 
  * Default constructor for DAOFactory using Text Log
  * The logging mechanism is chosen in step 4.3.
  * <p>
  * Connecting to the database is handled by confirmConnection() when a request for
  * a DAO is received.
  * <p>
  * Messages will appear in one or more log files whose names 
  * start with 'DAOFactory'.  
  * <p>
  * In addition to normal directory names this Log class also accepts 
  * 'user.home' and 'user.dir', and will assume they are valid System properties. 
  * <p>
  * In this case the files will be found in the directory returned by System.getProperies("user.home") 
  * @see com.orindasoft.demo.generated.DAOFactory#confirmConnection()
  */                                   
  public DAOFactory() 
    {                                                 
    theLog = new com.orindasoft.pub.TextLog("user.home","DAOFactory");
    // Stop debug messages from being ignored by logger
    theLog.debugOn();
    // Make sure log is flushed every statement as we are in debug mode
    theLog.setAutoFlush(true);
    theLog.debug("DAOFactory - Started");
    }                                                  
                                                      
  /** 
  * Create an instance of DAOFactory using a database connection and an instance of LogInterface 
  *  @param Connection theConnection A database connection 
  *  @param LogInterface theLog An instance of a class that implements com.orindasoft.pub.LogInterface 
  */ 
  public DAOFactory(Connection theConnection, LogInterface theLog) 
    { 
    this.theConnection = theConnection; 
    this.theLog = theLog; 
    theLog.debug("DAOFactory - Started with Connection and LogInterface");
    } 
   
  /** 
  * Create an instance of DAOFactory using an instance of LogInterface  
  *  @param LogInterface theLog An instance of a class that implements com.orindasoft.pub.LogInterface  
  */                                   
  public DAOFactory(LogInterface theLog)      
    {                                                 
    this.theLog = theLog;                             
    theLog.debug("DAOFactory - Started with LogInterface");
    }                                                  
     
  /** 
  * Prepare batch commit statement
  * @since 5.0.2496 
  */ 
  protected java.sql.CallableStatement prepareBatchCommitStatement() throws CSDBException     
    {                                                                   
    java.sql.CallableStatement newStatement = null;                                      
                                                                     
    // Parse batch commit request...                          
    try                                                              
      {                                                                
      theLog.debug("prepareBatchCommitStatement - Starting to parse statement");
      newStatement = theConnection.prepareCall("BEGIN COMMIT WRITE BATCH NOWAIT; END;");    
      theLog.debug("prepareBatchCommitStatement - Finished parsing statement");
      }                                                                  
    catch (java.sql.SQLException e)                                    
      {                                                                   
      theLog.error("prepareBatchCommitStatement: Prepare Statement failed with " + e.toString());
      CSDBException e2 = new CSDBException(e.getErrorCode(),e.getMessage(),"commit batch","DAOFactory");
      throw (e2);   
      }       
              
    return(newStatement);  
                        
    }                      
                         
  /**                                                        
  * Commit changes to the database without waiting for confirmation from the redo log.    
  * This method uses the asyncrhornous commit functionality of Oracle 10.2 and higher. 
  * A normal commit waits for a response indicating that changes made by the transaction  
  * are safely stored in the redo log. This form of commit assumes they will be stored, but 
  * if the database crashes within a few seconds of the call transactions that were 'committed' 
  * with this call may be lost. The plus side is that because uses asynchronous IO it's up to  
  * 100 times faster than a normal commit.  
  *   
  * WARNING: Do not use this method if you do not understand and accept the possibility  of data loss. 
  *   
  * @throws CSDBException if something goes wrong. This is most likely to 
  * if <code>batchUpdateSize</code> is a value other than 1. 
  */                                                         
  public void commitWriteBatchNowait() throws CSDBException      
    {                                  
     
    if (theConnection != null)
      {                                  
      try
        {
        theLog.debug("DAOFactory - Committing Changes");
                                                                                
        if (batchCommitStatement == null)                                              
          {      
          // Parse batch commit statement    
          batchCommitStatement = prepareBatchCommitStatement();
          }    
              
        batchCommitStatement.execute();
        }
      catch (java.sql.SQLException e)
        {
        theLog.error("DAOFactory - Batch Commit Failed:");
        theLog.error(e);
        CSDBException e2 = new CSDBException(e.getErrorCode(),e.getMessage(),"commit","DAOFactory");
        throw(e2);
        }
      }                            
    }                            
   
  
  /**
  * Set String that if non-null should contain a valid Oracle time zone name.
  * This is used for working with oracle.sql.TIMESTAMPLTZ, which needs 
  * an OracleConnection that has been made time zone aware in order to work.
  * A list of valid time zones is stored in V$TIMEZONE_NAMES. 
  * @see oracle.sql.OracleConnection.setSessionTimeZone()
  * @see confirmConnection()
  * @since JDBCWizard 4.0.2145
  * @since Oracle V9.0.1
  */
  public void setOracleTimeZoneName(String oracleTimeZoneName)   
    {                                  
    this.oracleTimeZoneName = oracleTimeZoneName;      
    }                                  
  /** 
  * Change value for implict SQL statement cache size
  * A value of zero turns off the implicit SQL statement cache.
  */
  public  void setImplicitSqlCacheSize(int newSqlCacheSize)
    {                                  
    implicitSqlCacheSize = newSqlCacheSize;      
    }                                  
   
  /** 
  * Return value for implict SQL statement cache size
  */
  public int  getImplicitSqlCacheSize()
    {                                  
    return(implicitSqlCacheSize);      
    }                                  
   
  
   
  /**  
  * Set or reset the database connection and update all 
  * the classes that are using it.
  * @param Connection newConnection A database connection  
  */       
  public void setConnection(Connection newConnection)  
    {                                               
    theConnection = newConnection;          
    theLog.debug("DAOFactory - Connection Set");
    
    // Change size of implicit connection cache if needed
    if (theConnection instanceof OracleConnection)
      {
      if (implicitSqlCacheSize > -1)
        {
        try
          {
          if (implicitSqlCacheSize == 0)
            {
            if (((OracleConnection)newConnection).getImplicitCachingEnabled())  
              {
              theLog.debug("DAOFactory - disabling implicit statement cache" );
              ((OracleConnection)theConnection).setImplicitCachingEnabled(false);
              }
            }
          else 
            {
            if ( ! ((OracleConnection)newConnection).getImplicitCachingEnabled())  
              {
              theLog.debug("DAOFactory - enabling implicit statement cache" );
              ((OracleConnection)theConnection).setImplicitCachingEnabled(true);
              }
             
            if (((OracleConnection)theConnection).getStatementCacheSize()!= implicitSqlCacheSize)  
              {
              theLog.debug("DAOFactory - setting implicit connection cache size to " + implicitSqlCacheSize );
              ((OracleConnection)theConnection).setStatementCacheSize(implicitSqlCacheSize);
              }
             
            }
          }
        catch (Exception e)
          {
          theLog.error("setConnection: error while setting implicit connection cache");
          theLog.error(e);
          }
        }
      }
    
    // Tell CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE about new Connection
    if (theCursorExampleDirectFlightAvailable != null)
      {                                               
      theLog.debug("DAOFactory - Update CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE DAO with new connection");
      theCursorExampleDirectFlightAvailable.setConnection(theConnection);
      }                                           
      
    // Tell CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS about new Connection
    if (theCursorExampleFindDirectFlights != null)
      {                                               
      theLog.debug("DAOFactory - Update CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS DAO with new connection");
      theCursorExampleFindDirectFlights.setConnection(theConnection);
      }                                           
      
    // Tell CURSOR_EXAMPLE.GETLISTS about new Connection
    if (theCursorExampleGetlists != null)
      {                                               
      theLog.debug("DAOFactory - Update CURSOR_EXAMPLE.GETLISTS DAO with new connection");
      theCursorExampleGetlists.setConnection(theConnection);
      }                                           
      
    // Tell OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY about new Connection
    if (theObjectArrayExampleAddBookingsObjectArray != null)
      {                                               
      theLog.debug("DAOFactory - Update OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY DAO with new connection");
      theObjectArrayExampleAddBookingsObjectArray.setConnection(theConnection);
      }                                           
      
    // Tell OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS about new Connection
    if (theObjectArrayExampleGetObjectArrayOfFlights != null)
      {                                               
      theLog.debug("DAOFactory - Update OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS DAO with new connection");
      theObjectArrayExampleGetObjectArrayOfFlights.setConnection(theConnection);
      }                                           
      
    // Tell PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY about new Connection
    if (thePackageArrayExampleAddBookingsPlsqlArray != null)
      {                                               
      theLog.debug("DAOFactory - Update PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY DAO with new connection");
      thePackageArrayExampleAddBookingsPlsqlArray.setConnection(theConnection);
      }                                           
      
    // Tell PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS about new Connection
    if (thePackageArrayExampleGetPlsqlArrayOfFlights != null)
      {                                               
      theLog.debug("DAOFactory - Update PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS DAO with new connection");
      thePackageArrayExampleGetPlsqlArrayOfFlights.setConnection(theConnection);
      }                                           
      
    // Tell PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY about new Connection
    if (thePackageIdxarrayExampleAddBookingsPlsqlArray != null)
      {                                               
      theLog.debug("DAOFactory - Update PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY DAO with new connection");
      thePackageIdxarrayExampleAddBookingsPlsqlArray.setConnection(theConnection);
      }                                           
      
    // Tell PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS about new Connection
    if (thePackageIdxarrayExampleGetPlsqlArrayOfFlights != null)
      {                                               
      theLog.debug("DAOFactory - Update PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS DAO with new connection");
      thePackageIdxarrayExampleGetPlsqlArrayOfFlights.setConnection(theConnection);
      }                                           
      
    // Tell AircraftMgr about new Connection
    if (TheAircraftMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update AircraftMgr DAO with new connection");
      TheAircraftMgr.setConnection(theConnection);
      }                                           
      
    // Tell AirlinesMgr about new Connection
    if (TheAirlinesMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update AirlinesMgr DAO with new connection");
      TheAirlinesMgr.setConnection(theConnection);
      }                                           
      
    // Tell AirportsMgr about new Connection
    if (TheAirportsMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update AirportsMgr DAO with new connection");
      TheAirportsMgr.setConnection(theConnection);
      }                                           
      
    // Tell BookingsMgr about new Connection
    if (TheBookingsMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update BookingsMgr DAO with new connection");
      TheBookingsMgr.setConnection(theConnection);
      }                                           
      
    // Tell CustomersMgr about new Connection
    if (TheCustomersMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update CustomersMgr DAO with new connection");
      TheCustomersMgr.setConnection(theConnection);
      }                                           
      
    // Tell FlightsMgr about new Connection
    if (TheFlightsMgr != null)
      {                                               
      theLog.debug("DAOFactory - Update FlightsMgr DAO with new connection");
      TheFlightsMgr.setConnection(theConnection);
      }                                           
      
    // Tell SEQUENTIAL_NUMBER_GENERATOR about new Connection
    if (theSequentialNumberGenerator != null)
      {                                               
      theLog.debug("DAOFactory - Update SEQUENTIAL_NUMBER_GENERATOR DAO with new connection");
      theSequentialNumberGenerator.setConnection(theConnection);
      }                                           
      
    // Tell ChangeFlightDates about new Connection
    if (theChangeFlightDates != null)
      {                                               
      theLog.debug("DAOFactory - Update ChangeFlightDates DAO with new connection");
      theChangeFlightDates.setConnection(theConnection);
      }                                           
      
    // Tell CustcomerAdd about new Connection
    if (theCustcomerAdd != null)
      {                                               
      theLog.debug("DAOFactory - Update CustcomerAdd DAO with new connection");
      theCustcomerAdd.setConnection(theConnection);
      }                                           
      
    // Tell CustomerDelete about new Connection
    if (theCustomerDelete != null)
      {                                               
      theLog.debug("DAOFactory - Update CustomerDelete DAO with new connection");
      theCustomerDelete.setConnection(theConnection);
      }                                           
      
    // Tell CustomerUpdate about new Connection
    if (theCustomerUpdate != null)
      {                                               
      theLog.debug("DAOFactory - Update CustomerUpdate DAO with new connection");
      theCustomerUpdate.setConnection(theConnection);
      }                                           
      
    // Tell GetFlights about new Connection
    if (theGetFlights != null)
      {                                               
      theLog.debug("DAOFactory - Update GetFlights DAO with new connection");
      theGetFlights.setConnection(theConnection);
      }                                           
      
    }                                           
    
  
  /**
  * Get flag that controls whether LOBs are turned into byte[].
  * @return boolean useByteArraysForLongsAndLOBS 
  * @since 5.0.2314
  */
  public boolean getUseByteArraysForLongsAndLOBS()
    {
    return (useByteArraysForLongsAndLOBS);
    }
  
  /**
  * Set useByteArraysForLongsAndLOBS
  * @param boolean useByteArraysForLongsAndLOBS Turn lobs into byte[]
  * @since 5.0.2314
  */
  public void setUseByteArraysForLongsAndLOBS(boolean useByteArraysForLongsAndLOBS)
    {
    this.useByteArraysForLongsAndLOBS = useByteArraysForLongsAndLOBS;
    theLog.debug("useByteArraysForLongsAndLOBS set to " + useByteArraysForLongsAndLOBS);
    }
  
  /**
  * Get keepFiles
  * @return boolean keepFiles Keep generated files after JVM exits
  */
  public boolean getKeepFiles()
    {
    return( keepFiles);
    }                                  
  
  /**
  * Set keepFiles
  * @param boolean keepFiles Keep generated files after JVM exits
  */
  public void setKeepFiles(boolean keepFiles )
    {
    this.keepFiles = keepFiles;
    theLog.debug("keepFiles set to " + keepFiles);
    }
  
  /**
  * Set keepLobs
  * @param boolean keepLobs Keep Lobs as pointers rather than turn them into files.
  * @since 4.0.2108
  */
  public void setKeepLobs(boolean keepLobs )
    {
    this.keepLobs = keepLobs;
    theLog.debug("keepLobs set to " + keepLobs);
    }
  
  /**
  * Get keepLobs
  * @return boolean keepLobs Keep Lobs as pointers rather than turn them into files.
  */
  public boolean getKeepLobs()
    {
    return(keepLobs);
    }                                  
   
  /**                                                        
  * Set Array size for fetches from the database.    
  * The best value for this parameter is usually about 50.
  * @param int newSize New number of records to be fetched each time when issuing queries.
  */                                                         
  public void setArrayFetchSize(int newSize)      
    {                                  
    arrayFetchSize = newSize;               
     
    if (theConnection != null)
      {                                  
      try
        {
        theLog.debug("DAOFactory - Changing array fetch size to " + newSize);
        // Tell Oracle Driver to send stuff back in batches of arrayFetchSize
        ((OracleConnection)theConnection).setDefaultRowPrefetch (arrayFetchSize);
        }
      catch (java.sql.SQLException e)
        {
        theLog.error("DAOFactory - Changing array fetch size failed:");
        theLog.error(e);
        }
      }                            
      
    }                            
                             
  /**                                                        
  * Get Array size for fetches from the database.    
  * @return int Current array fetch size 
  */                                                         
  public int getArrayFetchSize()      
    {                                  
    return(arrayFetchSize);               
    }                            
                             
  /**                                                        
  * Set Array size for batch updates.    
  * If set to a value other than 1 Oracle's JDBC driver will avoid 
  * talking to the database until it has to. If asked to do an 
  * INSERT, UPDATE or DELETE it will remember the statement and 
  * issue it when asked to commit or when the array for batch
  * updates is full. This feature has nasty side effects
  * and should be used with care. 
  */                                                         
  public void setBatchUpdateSize(int newSize)      
    {                                  
    batchUpdateSize = newSize;               
     
    if (theConnection != null)
      {                                  
      try
        {
        theLog.debug("DAOFactory - Changing update batch size to " + newSize);
        // Tell Oracle Driver to send updates in batches of batchUpdateSize
        ((OracleConnection)theConnection).setDefaultExecuteBatch (batchUpdateSize);
        }
      catch (java.sql.SQLException e)
        {
        theLog.error("DAOFactory - Change update batch failed:");
        theLog.error(e);
        }
      }                            
      
    }                            
                             
  /**                                                        
  * Get Array size for batch updates.    
  * @return int Current batch update array size 
  */                                                         
  public int getBatchUpdateSize()      
    {                                  
    return(batchUpdateSize);               
    }                            
                             
   
  /**                                                        
  * Commit changes to the database.    
  * @throws CSDBException if something goes wrong. This is most likely to 
  * if <code>batchUpdateSize</code> is a value other than 1. 
  */                                                         
  public void commit() throws CSDBException      
    {                                  
     
    if (theConnection != null)
      {                                  
      try
        {
        theLog.debug("DAOFactory - Committing Changes");
        theConnection.commit();
        }
      catch (java.sql.SQLException e)
        {
        theLog.error("DAOFactory - Commit Failed:");
        theLog.error(e);
        CSDBException e2 = new CSDBException(e.getErrorCode(),e.getMessage(),"commit","DAOFactory");
        throw(e2);
        }
      }                            
    }                            
   
  /**                                                        
  * Rollback changes to the database.    
  */                                                         
  public void rollback() throws CSException      
    {                                  
     
    if (theConnection != null)
      {                                  
      try
        {
        theLog.debug("DAOFactory - Rolling back changes");
        theConnection.rollback();
        }
      catch (java.sql.SQLException e)
        {
        theLog.error("DAOFactory - Rollback Failed:");
        theLog.error(e);
        throw (new CSDBException(e.getErrorCode(),e.getMessage(),"rollback","DAOFactory"));
        }
      }                            
    }                            
   
  /**  
  * Alter a newly created connection object.  
  * <p> 
  * If you need to alter the connection after it is created overide this method.
  * make sure you call 'super();' as the first step. 
  * <p> 
  * @param String connectionContext Where in the DAO factory class we are being called from
  * @param Connection newConnection The new connection object
  * @since JDBCWizard V5.0.2428 
  */
  public void doPostGetConnectionAction(String connectionContext, Connection newConnection) throws CSException 
    {                                               
    // This method doesn't do anything unless you override it.
    }                                               
   
   
  /**  
  * Confirm that our Connection object is not null. Create one if needed.  
  * This method's behaviour is controlled by step 4.3.
  * <p> 
  * <p> 
  * If you call the releaseResources() method of this class all existing DAO objects
  * will lose their Connection objects. In addition to creating making sure a Connection exists this 
  * method makes sure that all the DAO objects it spawned previously are given the new Connection.
  * <p> 
  * @since JDBCWizard V5.0.2428 Support for doPostGetConnectionAction() and doPostGetDataSourceAction()
  * <p> 
  * A dedicated Connection object will be created using the value entered as a
  * Connection Name in step 4.3. JDBCWizard
  * doesn't verify this value. It should look something like:
  * <p><code>
  * jdbc:oracle:thin:username/password@host:port:sid
  * <p></code> 
  * For example: 
  * <p><code>
  * jdbc:oracle:thin:ORINDADEMO/ORINDADEMO@localhost:1521:ORCL
  * </code>
  */       
  public void confirmConnection(String connectionContext) throws CSException 
    {                                               
    if (theConnection == null)
      {   
      //
      // Attempt to load database driver...
      try
        {
        Class.forName ("oracle.jdbc.driver.OracleDriver");
        }
      catch (ClassNotFoundException oe)
        {
        theLog.error("DAOFactory:Oracle Driver not found " + oe);
        throw new CSException("Unable to find Oracle driver");
        }
      
      //
      // Attempt to login to the DB...
      // The connection string should be in the format:
      // jdbc:oracle:thin:user/password@hostname:port:sid
      //
      try
        {
        
        theConnection = (OracleConnection)java.sql.DriverManager.getConnection (
             "jdbc:oracle:thin:ORINDADEMO2814/orindademo@demodb.orindasoft.com:1521:XE");
        
        theLog.info("Logged in as user " + ((OracleConnection)theConnection).getUserName());
        
        // By default JDBC drivers commit automatically. Turn this off...
        theConnection.setAutoCommit(false);
        
        // Tell Oracle Driver to send stuff back in batches of arrayFetchSize
        ((OracleConnection)theConnection).setDefaultRowPrefetch (arrayFetchSize);
        
        // Tell Oracle Driver to send updates in batches of batchUpdateSize
        ((OracleConnection)theConnection).setDefaultExecuteBatch (batchUpdateSize);
        
        if (oracleTimeZoneName != null)
          {
          // Tell Oracle Driver what our time zone is so that
          // oracle.sql.TIMEZONELTZ works
          ((OracleConnection)theConnection).setSessionTimeZone(oracleTimeZoneName);
          theLog.debug("Session Time Zone set to '" + oracleTimeZoneName + "'");
          }
        
        }
      catch (java.sql.SQLException e)
        {
        String errorDescription = null;
        if (e.getMessage().startsWith("Io exception: Connection refused"))
          {
          errorDescription = "Io Error: Contact made but connection refused. Check that instance is up and the listener is running";
          }
        else if (e.getErrorCode() == 17002 /* Io Exception */)
          {
          errorDescription = "Network Error: Check Hostname and Port are valid";
          }
        else if (e.getErrorCode() == 1017 /* Invalid Username/Password */)
          {
          errorDescription = "Login Error: Check Username and password are valid";
          }
        else if (e.getErrorCode() == 1033 /* Startup of Shutdown in progress */)
          {
          errorDescription = "Server Error: Startup of Shutdown in progress";
          }
        else if (e.getErrorCode() == 12535 /* operation timed out */)
          {
          errorDescription = "Io Error: Hostname known but not reachable";
          }
      
        if (errorDescription != null) 
          {
          theLog.error("SqlException Thrown in DAOFactory constructor:");
          theLog.error(errorDescription);
          throw new CSException(errorDescription);
          }
      
        theLog.error("SqlException Thrown in DAOFactory constructor:");
        theLog.error(e);
        throw new CSException(e.toString());
        }
      catch (Exception e)
        {
        theLog.error("Unexpected Exception Thrown in DAOFactory constructor:");
        theLog.error(e);
        throw new CSException(e.toString());
        }
      catch (Error e)
        {
        theLog.error("Unexpected Error Thrown in DAOFactory constructor:");
        theLog.error(e.toString());
        throw new CSException(e.toString());
        }
      
      setConnection(theConnection);
      }
    theLog.debug("DAOFactory - Connection Created");
    }                                           
    
  
   
  /**  
  * Confirm that our Connection object is not null. Create one if needed.  
  * This method's behaviour is controlled by step 4.3.
  * <p> 
  */       
  public void confirmConnection() throws CSException 
    {
    confirmConnection(null);
    }
   
  /**  
  * Get rid of the current database connection.
  * The behaviour of this method changes according to step 4.3.
  * @since JDBCWizard 4.0.2098 Connection is only commited if commitOnRelease == true
  * @since JDBCWizard 4.0.2107 Connection is only closed if closeOnRelease == true
  * @since JDBCWizard 5.0.2266 Close and Commit are independent of each other
  */       
  protected void releaseConnection()  
    {                                               
    if (theConnection != null)
      {   
      try
        {
        if (commitOnRelease)
          {
          theLog.debug("DAOFactory - Committing Changes");
          theConnection.commit();
          }
         
        if (closeOnRelease)
          {
          theLog.debug("DAOFactory - Closing Connection");
          theConnection.close();
          }
        }
      catch (java.sql.SQLException e)
        {
        theLog.error(e);
        }
      finally
        {
        theLog.debug("DAOFactory - Setting connection to null");
        theConnection = null;
        }
      }
    theLog.debug("DAOFactory - Connection Released");
    }
    
  
  /** 
  * Get DAO to access PL/SQL CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.CursorExampleDirectFlightAvailable
  */ 
  public com.orindasoft.demo.generated.plsql.CursorExampleDirectFlightAvailable getCursorExampleDirectFlightAvailablePlSqlDAO() throws CSException
    {                                               
    confirmConnection("getCursorExampleDirectFlightAvailablePlSqlDAO");
    
    if (theCursorExampleDirectFlightAvailable == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE");
      theCursorExampleDirectFlightAvailable = new com.orindasoft.demo.generated.plsql.CursorExampleDirectFlightAvailable(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CURSOR_EXAMPLE.DIRECT_FLIGHT_AVAILABLE");
    return(theCursorExampleDirectFlightAvailable);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.CursorExampleFindDirectFlights
  */ 
  public com.orindasoft.demo.generated.plsql.CursorExampleFindDirectFlights getCursorExampleFindDirectFlightsPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getCursorExampleFindDirectFlightsPlSqlDAO");
    
    if (theCursorExampleFindDirectFlights == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS");
      theCursorExampleFindDirectFlights = new com.orindasoft.demo.generated.plsql.CursorExampleFindDirectFlights(theConnection, theLog);
      
      // Set temporary file directory etc.
      theCursorExampleFindDirectFlights.setBufferSize(getBufferSize());
      theCursorExampleFindDirectFlights.setKeepFiles(getKeepFiles());
      theCursorExampleFindDirectFlights.setKeepLobs(getKeepLobs());
      theCursorExampleFindDirectFlights.setTempDir(getTempFileDir());
      theCursorExampleFindDirectFlights.setTempFilePrefix(getTempFilePrefix());
      theCursorExampleFindDirectFlights.setTempFileSuffix(getTempFileSuffix());
      theCursorExampleFindDirectFlights.setUseByteArraysForLongsAndLOBS(useByteArraysForLongsAndLOBS);
      theCursorExampleFindDirectFlights.setCreateTempLobsIfNeeded(true);
      theCursorExampleFindDirectFlights.setDeleteTempLobsAfterCall(true);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CURSOR_EXAMPLE.FIND_DIRECT_FLIGHTS");
    return(theCursorExampleFindDirectFlights);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL CURSOR_EXAMPLE.GETLISTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.CursorExampleGetlists
  */ 
  public com.orindasoft.demo.generated.plsql.CursorExampleGetlists getCursorExampleGetlistsPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getCursorExampleGetlistsPlSqlDAO");
    
    if (theCursorExampleGetlists == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CURSOR_EXAMPLE.GETLISTS");
      theCursorExampleGetlists = new com.orindasoft.demo.generated.plsql.CursorExampleGetlists(theConnection, theLog);
      
      // Set temporary file directory etc.
      theCursorExampleGetlists.setBufferSize(getBufferSize());
      theCursorExampleGetlists.setKeepFiles(getKeepFiles());
      theCursorExampleGetlists.setKeepLobs(getKeepLobs());
      theCursorExampleGetlists.setTempDir(getTempFileDir());
      theCursorExampleGetlists.setTempFilePrefix(getTempFilePrefix());
      theCursorExampleGetlists.setTempFileSuffix(getTempFileSuffix());
      theCursorExampleGetlists.setUseByteArraysForLongsAndLOBS(useByteArraysForLongsAndLOBS);
      theCursorExampleGetlists.setCreateTempLobsIfNeeded(true);
      theCursorExampleGetlists.setDeleteTempLobsAfterCall(true);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CURSOR_EXAMPLE.GETLISTS");
    return(theCursorExampleGetlists);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.ObjectArrayExampleAddBookingsObjectArray
  */ 
  public com.orindasoft.demo.generated.plsql.ObjectArrayExampleAddBookingsObjectArray getObjectArrayExampleAddBookingsObjectArrayPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getObjectArrayExampleAddBookingsObjectArrayPlSqlDAO");
    
    if (theObjectArrayExampleAddBookingsObjectArray == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY");
      theObjectArrayExampleAddBookingsObjectArray = new com.orindasoft.demo.generated.plsql.ObjectArrayExampleAddBookingsObjectArray(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access OBJECT_ARRAY_EXAMPLE.ADD_BOOKINGS_OBJECT_ARRAY");
    return(theObjectArrayExampleAddBookingsObjectArray);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.ObjectArrayExampleGetObjectArrayOfFlights
  */ 
  public com.orindasoft.demo.generated.plsql.ObjectArrayExampleGetObjectArrayOfFlights getObjectArrayExampleGetObjectArrayOfFlightsPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getObjectArrayExampleGetObjectArrayOfFlightsPlSqlDAO");
    
    if (theObjectArrayExampleGetObjectArrayOfFlights == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS");
      theObjectArrayExampleGetObjectArrayOfFlights = new com.orindasoft.demo.generated.plsql.ObjectArrayExampleGetObjectArrayOfFlights(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access OBJECT_ARRAY_EXAMPLE.GET_OBJECT_ARRAY_OF_FLIGHTS");
    return(theObjectArrayExampleGetObjectArrayOfFlights);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.PackageArrayExampleAddBookingsPlsqlArray
  */ 
  public com.orindasoft.demo.generated.plsql.PackageArrayExampleAddBookingsPlsqlArray getPackageArrayExampleAddBookingsPlsqlArrayPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getPackageArrayExampleAddBookingsPlsqlArrayPlSqlDAO");
    
    if (thePackageArrayExampleAddBookingsPlsqlArray == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY");
      thePackageArrayExampleAddBookingsPlsqlArray = new com.orindasoft.demo.generated.plsql.PackageArrayExampleAddBookingsPlsqlArray(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access PACKAGE_ARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY");
    return(thePackageArrayExampleAddBookingsPlsqlArray);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.PackageArrayExampleGetPlsqlArrayOfFlights
  */ 
  public com.orindasoft.demo.generated.plsql.PackageArrayExampleGetPlsqlArrayOfFlights getPackageArrayExampleGetPlsqlArrayOfFlightsPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getPackageArrayExampleGetPlsqlArrayOfFlightsPlSqlDAO");
    
    if (thePackageArrayExampleGetPlsqlArrayOfFlights == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS");
      thePackageArrayExampleGetPlsqlArrayOfFlights = new com.orindasoft.demo.generated.plsql.PackageArrayExampleGetPlsqlArrayOfFlights(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access PACKAGE_ARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS");
    return(thePackageArrayExampleGetPlsqlArrayOfFlights);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleAddBookingsPlsqlArray
  */ 
  public com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleAddBookingsPlsqlArray getPackageIdxarrayExampleAddBookingsPlsqlArrayPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getPackageIdxarrayExampleAddBookingsPlsqlArrayPlSqlDAO");
    
    if (thePackageIdxarrayExampleAddBookingsPlsqlArray == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY");
      thePackageIdxarrayExampleAddBookingsPlsqlArray = new com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleAddBookingsPlsqlArray(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access PACKAGE_IDXARRAY_EXAMPLE.ADD_BOOKINGS_PLSQL_ARRAY");
    return(thePackageIdxarrayExampleAddBookingsPlsqlArray);
    }                                           
    
  /** 
  * Get DAO to access PL/SQL PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleGetPlsqlArrayOfFlights
  */ 
  public com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleGetPlsqlArrayOfFlights getPackageIdxarrayExampleGetPlsqlArrayOfFlightsPlSqlDAO() throws CSException
    {                                               
    confirmConnection("getPackageIdxarrayExampleGetPlsqlArrayOfFlightsPlSqlDAO");
    
    if (thePackageIdxarrayExampleGetPlsqlArrayOfFlights == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS");
      thePackageIdxarrayExampleGetPlsqlArrayOfFlights = new com.orindasoft.demo.generated.plsql.PackageIdxarrayExampleGetPlsqlArrayOfFlights(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access PACKAGE_IDXARRAY_EXAMPLE.GET_PLSQL_ARRAY_OF_FLIGHTS");
    return(thePackageIdxarrayExampleGetPlsqlArrayOfFlights);
    }                                           
    
  /** 
  * Get DAO to access Table AIRCRAFT
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.AircraftMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.AircraftMgr getAircraftTableDAO() throws CSException
    {                                               
    confirmConnection("getAircraftTableDAO");
     
    if (TheAircraftMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access AIRCRAFT");
      TheAircraftMgr = new com.orindasoft.demo.generated.table.manager.AircraftMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access AIRCRAFT");
    return(TheAircraftMgr);
    }                                           
    
  /** 
  * Get DAO to access Table AIRLINES
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.AirlinesMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.AirlinesMgr getAirlinesTableDAO() throws CSException
    {                                               
    confirmConnection("getAirlinesTableDAO");
     
    if (TheAirlinesMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access AIRLINES");
      TheAirlinesMgr = new com.orindasoft.demo.generated.table.manager.AirlinesMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access AIRLINES");
    return(TheAirlinesMgr);
    }                                           
    
  /** 
  * Get DAO to access Table AIRPORTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.AirportsMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.AirportsMgr getAirportsTableDAO() throws CSException
    {                                               
    confirmConnection("getAirportsTableDAO");
     
    if (TheAirportsMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access AIRPORTS");
      TheAirportsMgr = new com.orindasoft.demo.generated.table.manager.AirportsMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access AIRPORTS");
    return(TheAirportsMgr);
    }                                           
    
  /** 
  * Get DAO to access Table BOOKINGS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.BookingsMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.BookingsMgr getBookingsTableDAO() throws CSException
    {                                               
    confirmConnection("getBookingsTableDAO");
     
    if (TheBookingsMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access BOOKINGS");
      TheBookingsMgr = new com.orindasoft.demo.generated.table.manager.BookingsMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access BOOKINGS");
    return(TheBookingsMgr);
    }                                           
    
  /** 
  * Get DAO to access Table CUSTOMERS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.CustomersMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.CustomersMgr getCustomersTableDAO() throws CSException
    {                                               
    confirmConnection("getCustomersTableDAO");
     
    if (TheCustomersMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CUSTOMERS");
      TheCustomersMgr = new com.orindasoft.demo.generated.table.manager.CustomersMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CUSTOMERS");
    return(TheCustomersMgr);
    }                                           
    
  /** 
  * Get DAO to access Table FLIGHTS
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.table.manager.FlightsMgr
  */ 
  public com.orindasoft.demo.generated.table.manager.FlightsMgr getFlightsTableDAO() throws CSException
    {                                               
    confirmConnection("getFlightsTableDAO");
     
    if (TheFlightsMgr == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access FLIGHTS");
      TheFlightsMgr = new com.orindasoft.demo.generated.table.manager.FlightsMgr(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access FLIGHTS");
    return(TheFlightsMgr);
    }                                           
    
  /** 
  * Get DAO to access Sequence SEQUENTIAL_NUMBER_GENERATOR
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sequence.SequentialNumberGenerator
  */ 
  public com.orindasoft.demo.generated.sequence.SequentialNumberGenerator getSequentialNumberGeneratorSequenceDAO()  throws CSException
    {                                               
    confirmConnection("getSequentialNumberGeneratorSequenceDAO");
     
    if (theSequentialNumberGenerator == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access SEQUENTIAL_NUMBER_GENERATOR");
      theSequentialNumberGenerator = new com.orindasoft.demo.generated.sequence.SequentialNumberGenerator(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access SEQUENTIAL_NUMBER_GENERATOR");
    return(theSequentialNumberGenerator);
    }                                           
    
  /** 
  * Get DAO to access SQL Statement ChangeFlightDates
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sql.ChangeFlightDates
  */ 
  public com.orindasoft.demo.generated.sql.ChangeFlightDates getChangeFlightDatesSqlDAO() throws CSException
    {                                               
    confirmConnection("getChangeFlightDatesSqlDAO");
     
    if (theChangeFlightDates == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access ChangeFlightDates");
      theChangeFlightDates = new com.orindasoft.demo.generated.sql.ChangeFlightDates(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access ChangeFlightDates");
    return(theChangeFlightDates);
    }                                           
    
  /** 
  * Get DAO to access SQL Statement CustcomerAdd
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sql.CustcomerAdd
  */ 
  public com.orindasoft.demo.generated.sql.CustcomerAdd getCustcomerAddSqlDAO() throws CSException
    {                                               
    confirmConnection("getCustcomerAddSqlDAO");
     
    if (theCustcomerAdd == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CustcomerAdd");
      theCustcomerAdd = new com.orindasoft.demo.generated.sql.CustcomerAdd(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CustcomerAdd");
    return(theCustcomerAdd);
    }                                           
    
  /** 
  * Get DAO to access SQL Statement CustomerDelete
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sql.CustomerDelete
  */ 
  public com.orindasoft.demo.generated.sql.CustomerDelete getCustomerDeleteSqlDAO() throws CSException
    {                                               
    confirmConnection("getCustomerDeleteSqlDAO");
     
    if (theCustomerDelete == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CustomerDelete");
      theCustomerDelete = new com.orindasoft.demo.generated.sql.CustomerDelete(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CustomerDelete");
    return(theCustomerDelete);
    }                                           
    
  /** 
  * Get DAO to access SQL Statement CustomerUpdate
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sql.CustomerUpdate
  */ 
  public com.orindasoft.demo.generated.sql.CustomerUpdate getCustomerUpdateSqlDAO() throws CSException
    {                                               
    confirmConnection("getCustomerUpdateSqlDAO");
     
    if (theCustomerUpdate == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access CustomerUpdate");
      theCustomerUpdate = new com.orindasoft.demo.generated.sql.CustomerUpdate(theConnection, theLog);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access CustomerUpdate");
    return(theCustomerUpdate);
    }                                           
    
  /** 
  * Get DAO to access SQL Statement GetFlights
  * This method either creates a new instance of the access class or 
  * returns the existing instance. Note that it does not spawn a new instance 
  * each time its called. 
  * @since JDBCWizard 4.0.2139 confirmConnection() is called for existing DAO objects as well as new ones
  * @return com.orindasoft.demo.generated.sql.GetFlights
  */ 
  public com.orindasoft.demo.generated.sql.GetFlights getGetFlightsSqlDAO() throws CSException
    {                                               
    confirmConnection("getGetFlightsSqlDAO");
     
    if (theGetFlights == null)
      {                                               
      theLog.debug("DAOFactory - Creating DAO to access GetFlights");
      theGetFlights = new com.orindasoft.demo.generated.sql.GetFlights(theConnection, theLog);
      
      // Set temporary file directory etc.
      theGetFlights.setBufferSize(getBufferSize());
      theGetFlights.setKeepFiles(getKeepFiles());
      theGetFlights.setKeepLobs(getKeepLobs());
      theGetFlights.setTempDir(getTempFileDir());
      theGetFlights.setTempFilePrefix(getTempFilePrefix());
      theGetFlights.setTempFileSuffix(getTempFileSuffix());
      theGetFlights.setUseByteArraysForLongsAndLOBS(useByteArraysForLongsAndLOBS);
      }                                           
    
    theLog.debug("DAOFactory - Returning DAO to access GetFlights");
    return(theGetFlights);
    }                                           
    
   
  /** 
  * Release all db resources that we know to be in use. Further attempts to use this 
  *  will fail until we are given another connection to play with. 
  * We explicitly rollback at the end of this method. 
  *  @return boolean <code>true</code> if we didn't encounter any problems, otherwise <code>false</code> 
  */ 
   
  public boolean releaseResources() 
    { 
    boolean returnCode = true; 
    
    theLog.debug("DAOFactory - Attempting to release connection");
    
    try 
      { 
      if (batchCommitStatement != null)
        { 
        batchCommitStatement.close(); 
        batchCommitStatement = null; 
        } 
      
      if (theCursorExampleDirectFlightAvailable != null)
        { 
        if (theCursorExampleDirectFlightAvailable.hasResources())
          { 
          theCursorExampleDirectFlightAvailable.releaseResources(); 
          } 
        } 
      
      if (theCursorExampleFindDirectFlights != null)
        { 
        if (theCursorExampleFindDirectFlights.hasResources())
          { 
          theCursorExampleFindDirectFlights.releaseResources(); 
          } 
        } 
      
      if (theCursorExampleGetlists != null)
        { 
        if (theCursorExampleGetlists.hasResources())
          { 
          theCursorExampleGetlists.releaseResources(); 
          } 
        } 
      
      if (theObjectArrayExampleAddBookingsObjectArray != null)
        { 
        if (theObjectArrayExampleAddBookingsObjectArray.hasResources())
          { 
          theObjectArrayExampleAddBookingsObjectArray.releaseResources(); 
          } 
        } 
      
      if (theObjectArrayExampleGetObjectArrayOfFlights != null)
        { 
        if (theObjectArrayExampleGetObjectArrayOfFlights.hasResources())
          { 
          theObjectArrayExampleGetObjectArrayOfFlights.releaseResources(); 
          } 
        } 
      
      if (thePackageArrayExampleAddBookingsPlsqlArray != null)
        { 
        if (thePackageArrayExampleAddBookingsPlsqlArray.hasResources())
          { 
          thePackageArrayExampleAddBookingsPlsqlArray.releaseResources(); 
          } 
        } 
      
      if (thePackageArrayExampleGetPlsqlArrayOfFlights != null)
        { 
        if (thePackageArrayExampleGetPlsqlArrayOfFlights.hasResources())
          { 
          thePackageArrayExampleGetPlsqlArrayOfFlights.releaseResources(); 
          } 
        } 
      
      if (thePackageIdxarrayExampleAddBookingsPlsqlArray != null)
        { 
        if (thePackageIdxarrayExampleAddBookingsPlsqlArray.hasResources())
          { 
          thePackageIdxarrayExampleAddBookingsPlsqlArray.releaseResources(); 
          } 
        } 
      
      if (thePackageIdxarrayExampleGetPlsqlArrayOfFlights != null)
        { 
        if (thePackageIdxarrayExampleGetPlsqlArrayOfFlights.hasResources())
          { 
          thePackageIdxarrayExampleGetPlsqlArrayOfFlights.releaseResources(); 
          } 
        } 
      
      if (TheAircraftMgr != null)
        { 
        if (TheAircraftMgr.hasResources())
          { 
          TheAircraftMgr.releaseResources(); 
          } 
        } 
      
      if (TheAirlinesMgr != null)
        { 
        if (TheAirlinesMgr.hasResources())
          { 
          TheAirlinesMgr.releaseResources(); 
          } 
        } 
      
      if (TheAirportsMgr != null)
        { 
        if (TheAirportsMgr.hasResources())
          { 
          TheAirportsMgr.releaseResources(); 
          } 
        } 
      
      if (TheBookingsMgr != null)
        { 
        if (TheBookingsMgr.hasResources())
          { 
          TheBookingsMgr.releaseResources(); 
          } 
        } 
      
      if (TheCustomersMgr != null)
        { 
        if (TheCustomersMgr.hasResources())
          { 
          TheCustomersMgr.releaseResources(); 
          } 
        } 
      
      if (TheFlightsMgr != null)
        { 
        if (TheFlightsMgr.hasResources())
          { 
          TheFlightsMgr.releaseResources(); 
          } 
        } 
      
      if (theSequentialNumberGenerator != null)
        { 
        if (theSequentialNumberGenerator.hasResources())
          { 
          theSequentialNumberGenerator.releaseResources(); 
          } 
        } 
      
      if (theChangeFlightDates != null)
        { 
        if (theChangeFlightDates.hasResources())
          { 
          theChangeFlightDates.releaseResources(); 
          } 
        } 
      
      if (theCustcomerAdd != null)
        { 
        if (theCustcomerAdd.hasResources())
          { 
          theCustcomerAdd.releaseResources(); 
          } 
        } 
      
      if (theCustomerDelete != null)
        { 
        if (theCustomerDelete.hasResources())
          { 
          theCustomerDelete.releaseResources(); 
          } 
        } 
      
      if (theCustomerUpdate != null)
        { 
        if (theCustomerUpdate.hasResources())
          { 
          theCustomerUpdate.releaseResources(); 
          } 
        } 
      
      if (theGetFlights != null)
        { 
        if (theGetFlights.hasResources())
          { 
          theGetFlights.releaseResources(); 
          } 
        } 
      } 
    catch (Exception e) 
      { 
      theLog.warning(e.toString()); 
      returnCode = false; 
      } 
    
    releaseConnection();
    theLog.debug("DAOFactory- Finished releasing connection");
    
    return(returnCode); 
    } 
  
  /** 
  * Check to see if we are using Oracle Resources
  *  will fail until we are given another connection to play with. 
  * We explicitly rollback at the end of this method. 
  * @return <code>true</code> if we are using resources
  * @return <code>false</code> if we are not using resources
  */ 
  public boolean hasResources() 
    { 
    if (theConnection == null) 
      { 
      return (false); 
      } 
    
    return(true); 
    } 
  
  /**
  * Set new file io buffer size. This will only affect DAO's created after this method is called
  * @param int bufferSize A new Buffer size in bytes.
  * @since 4.0.2043
  */
  public void setBufferSize(int bufferSize)
    {
    this.bufferSize = bufferSize;
    theLog.debug("bufferSize set to " + bufferSize);
    }
  
  /**
  * Set new value for the commit-on-release flag
  * @param boolean commitOnRelease Whether this class should commit connections when they are no longer needed.
  * @since JDBCWizard 4.0.2098
  */
  public void setCommitOnRelease(boolean commitOnRelease)
    {
    this.commitOnRelease = commitOnRelease;
    theLog.debug("commitOnRelease set to " + commitOnRelease);
    }
  
  /**
  * Set new value for the close-on-release flag
  * @param boolean closeOnRelease Whether this class should close connections when they are no longer needed.
  * @since JDBCWizard 4.0.2107
  */
  public void setCloseOnRelease(boolean closeOnRelease)
    {
    this.closeOnRelease = closeOnRelease;
    theLog.debug("closeOnRelease set to " + closeOnRelease);
    }
  
  /**
  * Return current LogInterface object.
  * Returns the current logging object.
  * @return com.orindasoft.pub.LogInterface
  * @since 5.0.2023
  */
  public com.orindasoft.pub.LogInterface getCurrentLogInterface()
    {
    return(theLog);
    }
  
  /**
  * Return a long object loader.
  * The variable lobLoader is null until this method is called for the first time.
  * @return com.orindasoft.pub.LongObjectLoader A long object loader
  * @since 4.0.2108
  */
  public com.orindasoft.pub.LongObjectLoader getLoader()
    {
    if (lobLoader == null)                                   
      {                                                             
      lobLoader = new com.orindasoft.pub.LongObjectLoader(); 
      }                                      
     
    lobLoader.setBufferSize(bufferSize);
     
    return(lobLoader);
    }
  
  /**
  * Set temporary directory - only affects DAOs created after this method is called
  * @param java.io.File tempFileDir a new Temporary Directory
  * @throws CSException if the directory is not viable
  * @since 4.0.2043
  */
  public void setTempDir(java.io.File tempFileDir) throws CSException
    {
    if (tempFileDir == null)                                   
      {                                                             
      throw (new CSException("Attempt made to set tempFileDir to null")); 
      }                                      
    else if (! tempFileDir.exists())       
      {       
      try    
        {     
        theLog.info("Creating temporary directory " + tempFileDir.getAbsolutePath()); 
        tempFileDir.mkdirs(); 
        }  
      catch (Exception e) 
        { 
        throw (new CSException("tempFileDir " + tempFileDir.getAbsolutePath() + " can not be created"));  
        } 
      }  
    
    this.tempFileDir = tempFileDir;
    theLog.debug("tempFileDir set to " + tempFileDir.getAbsolutePath());
    }
  
  /**
  * Set the prefix used for generating temporary files
  * @since 4.0.2043
  */
  public void setTempFilePrefix(String tempFilePrefix)
    {
    this.tempFilePrefix = tempFilePrefix;
    }
  
  /**
  * Set the suffix used for generating temporary files
  * @since 4.0.2043
  */
  public void setTempFileSuffix(String tempFileSuffix)
    {
    this.tempFileSuffix = tempFileSuffix;
    }
  
  /**
  * Get current file io buffer size
  * @return int bufferSize Buffer size in bytes.
  */
  public int getBufferSize()
    {
    return (bufferSize);
    }
  
  /**
  * Get current temporary directory
  * @return java.io.File tempFileDir the temporary Directory
  */
  public java.io.File getTempFileDir()
    {
    return(tempFileDir);
    }
  
  /**
  * Get current prefix used for generating temporary files
  */
  public String getTempFilePrefix()
    {
    return (tempFilePrefix);
    }
  
  /**
  * Get current suffix used for generating temporary files
  */
  public String getTempFileSuffix()
    {
    return (tempFileSuffix);
    }
  
  } // Generated by JDBCWizard 6.0.2814  
